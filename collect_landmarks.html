<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Landmarks captures</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <label for="cameraSelect">Choose Camera:</label>
  <select id="cameraSelect"></select>
  <button id="saveLandmarkBtn">Save Landmark</button>
  <button id="downloadBtn">Download CSV</button>
  <video id="input_video" autoplay style="display:none;"></video>
  <canvas id="output_canvas"></canvas>
  <script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const cameraSelect = document.getElementById('cameraSelect');
    const saveLandmarkBtn = document.getElementById('saveLandmarkBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    let currentStream = null;
    let lastLandmarks = null;
    let collectedData = [];

    // List cameras
    async function getCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(device => device.kind === 'videoinput');
      cameraSelect.innerHTML = '';
      videoDevices.forEach((device, i) => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.text = device.label || `Camera ${i + 1}`;
        cameraSelect.appendChild(option);
      });
    }

    // Start stream from selected camera
    async function startCamera(deviceId) {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      const constraints = {
        video: { deviceId: { exact: deviceId } }
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      currentStream = stream;
      videoElement.srcObject = stream;
      videoElement.onloadedmetadata = () => {
        videoElement.play();
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
      };
    }

    cameraSelect.addEventListener('change', () => {
      startCamera(cameraSelect.value);
    });

    // On load, get cameras and start the first one
    getCameras().then(() => {
      if (cameraSelect.options.length > 0) {
        startCamera(cameraSelect.value);
      }
    });

    // Initialize MediaPipe Hands
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });

    hands.onResults(results => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        for (const landmarks of results.multiHandLandmarks) {
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
          drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});
        }
        // Save the latest landmarks for saving
        lastLandmarks = results.multiHandLandmarks[0];
      } else {
        lastLandmarks = null;
      }
      canvasCtx.restore();
    });

    // Process video frames
    async function detectHands() {
      if (videoElement.readyState === 4) {
        await hands.send({image: videoElement});
      }
      requestAnimationFrame(detectHands);
    }

    videoElement.onplay = detectHands;

    // Save landmark button
    saveLandmarkBtn.addEventListener('click', () => {
      if (!lastLandmarks) {
        alert('No hand detected!');
        return;
      }
      const label = prompt('Enter gesture label:');
      if (!label) return;
      // Flatten landmarks to array: x1, y1, z1, x2, y2, z2, ..., x21, y21, z21, label
      const row = [];
      lastLandmarks.forEach(lm => {
        row.push(lm.x, lm.y, lm.z);
      });
      row.push(label);
      collectedData.push(row);
      alert('Landmark saved!');
    });

    // Download CSV button
    downloadBtn.addEventListener('click', () => {
      if (collectedData.length === 0) {
        alert('No data to download!');
        return;
      }
      let csvContent = '';
      collectedData.forEach(row => {
        csvContent += row.join(',') + '\n';
      });
      const blob = new Blob([csvContent], {type: 'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'hand_landmarks.csv';
      a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>